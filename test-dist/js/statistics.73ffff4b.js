const Statistics = { history: { resources: [], buildings: [], achievements: [], sessions: [] }, currentSession: { startTime: Date.now(), clicksThisSession: 0, coinsEarnedThisSession: 0, buildingsBuiltThisSession: 0, achievementsUnlockedThisSession: 0 }, milestones: { firstClick: false, first100Coins: false, first10Buildings: false, first100Population: false, firstHour: false, firstAchievement: false }, init() { console.log('📊 Initializing statistics system...'); if (!GameState.statistics.totalResearchEarned) { GameState.statistics.totalResearchEarned = 0} if (!GameState.statistics.sessionsPlayed) { GameState.statistics.sessionsPlayed = 0} if (!GameState.statistics.achievementsUnlocked) { GameState.statistics.achievementsUnlocked = 0} if (!GameState.statistics.maxPopulation) { GameState.statistics.maxPopulation = 0} if (!GameState.statistics.maxHappiness) { GameState.statistics.maxHappiness = 100} if (!GameState.statistics.totalUpgradesPurchased) { GameState.statistics.totalUpgradesPurchased = 0} this.loadHistoricalData(); this.startNewSession(); this.setupDataCollection(); console.log('✅ Statistics system initialized')}, startNewSession() { this.currentSession = { startTime: Date.now(), clicksThisSession: GameState.statistics.totalClicks, coinsEarnedThisSession: GameState.statistics.totalCoinsEarned, buildingsBuiltThisSession: GameState.statistics.buildingsPurchased, achievementsUnlockedThisSession: GameState.statistics.achievementsUnlocked || 0 }; GameState.statistics.sessionsPlayed = (GameState.statistics.sessionsPlayed || 0) + 1}, recordDataPoint() { const timestamp = Date.now(); this.history.resources.push({ timestamp, coins: GameState.resources.coins, population: GameState.resources.population, happiness: GameState.resources.happiness, research: GameState.resources.research }); this.history.buildings.push({ timestamp, buildings: { ...GameState.buildings }, totalBuildings: Object.values(GameState.buildings).reduce((sum, count) => sum + count, 0) }); if (this.history.resources.length > 1000) { this.history.resources = this.history.resources.slice(-500)} if (this.history.buildings.length > 1000) { this.history.buildings = this.history.buildings.slice(-500)} }, setupDataCollection() { setInterval(() => { this.recordDataPoint(); this.updateMaxValues(); this.checkMilestones()}, 30000)}, updateMaxValues() { GameState.statistics.maxPopulation = Math.max( GameState.statistics.maxPopulation || 0, Math.floor(GameState.resources.population) ); GameState.statistics.maxHappiness = Math.max( GameState.statistics.maxHappiness || 0, Math.floor(GameState.resources.happiness) )}, checkMilestones() { if (!this.milestones.firstClick && GameState.statistics.totalClicks >= 1) { this.milestones.firstClick = true; this.recordMilestone('First Click', 'Made your first click!')} if (!this.milestones.first100Coins && GameState.statistics.totalCoinsEarned >= 100) { this.milestones.first100Coins = true; this.recordMilestone('First 100 Coins', 'Earned your first 100 coins!')} const totalBuildings = Object.values(GameState.buildings).reduce((sum, count) => sum + count, 0); if (!this.milestones.first10Buildings && totalBuildings >= 10) { this.milestones.first10Buildings = true; this.recordMilestone('City Builder', 'Built your first 10 buildings!')} if (!this.milestones.first100Population && GameState.resources.population >= 100) { this.milestones.first100Population = true; this.recordMilestone('Growing City', 'Reached 100 population!')} if (!this.milestones.firstHour && GameState.statistics.gameTime >= 3600) { this.milestones.firstHour = true; this.recordMilestone('Dedicated Player', 'Played for one hour!')} }, recordMilestone(name, description) { const milestone = { name, description, timestamp: Date.now(), gameTime: GameState.statistics.gameTime }; if (!this.history.achievements) { this.history.achievements = []} this.history.achievements.push(milestone); if (typeof UI !== 'undefined') { UI.showNotification(`🎯 Milestone: ${name}\n${description}`, 'achievement', 4000)} }, getCurrentSessionStats() { return { duration: Date.now() - this.currentSession.startTime, clicksThisSession: GameState.statistics.totalClicks - this.currentSession.clicksThisSession, coinsEarnedThisSession: GameState.statistics.totalCoinsEarned - this.currentSession.coinsEarnedThisSession, buildingsBuiltThisSession: GameState.statistics.buildingsPurchased - this.currentSession.buildingsBuiltThisSession, achievementsUnlockedThisSession: (GameState.statistics.achievementsUnlocked || 0) - this.currentSession.achievementsUnlockedThisSession }}, getComprehensiveStats() { const sessionStats = this.getCurrentSessionStats(); const totalBuildings = Object.values(GameState.buildings).reduce((sum, count) => sum + count, 0); return { totalClicks: GameState.statistics.totalClicks, totalCoinsEarned: GameState.statistics.totalCoinsEarned, totalResearchEarned: GameState.statistics.totalResearchEarned || 0, buildingsPurchased: GameState.statistics.buildingsPurchased, totalBuildings, gameTime: GameState.statistics.gameTime, sessionsPlayed: GameState.statistics.sessionsPlayed || 1, maxPopulation: GameState.statistics.maxPopulation || Math.floor(GameState.resources.population), maxHappiness: GameState.statistics.maxHappiness || Math.floor(GameState.resources.happiness), currentSession: sessionStats, clicksPerSecond: GameState.statistics.gameTime > 0 ? GameState.statistics.totalClicks / GameState.statistics.gameTime : 0, coinsPerSecond: GameState.statistics.gameTime > 0 ? GameState.statistics.totalCoinsEarned / GameState.statistics.gameTime : 0, buildingsPerHour: GameState.statistics.gameTime > 0 ? (GameState.statistics.buildingsPurchased / GameState.statistics.gameTime) * 3600 : 0, buildingBreakdown: { ...GameState.buildings }, achievementsUnlocked: GameState.statistics.achievementsUnlocked || 0, milestonesReached: Object.values(this.milestones).filter(Boolean).length }}, getBuildingStats() { const stats = {}; Object.keys(BuildingConfig).forEach(buildingType => { const config = BuildingConfig[buildingType]; const owned = GameState.buildings[buildingType] || 0; const totalCost = this.calculateTotalCostSpent(buildingType); const production = Buildings.getProduction(buildingType); stats[buildingType] = { name: config.name, owned, totalCostSpent: totalCost, currentProduction: production, tier: config.tier, category: config.category }}); return stats}, calculateTotalCostSpent(buildingType) { const config = BuildingConfig[buildingType]; const owned = GameState.buildings[buildingType] || 0; let totalCost = 0; for (let i = 0; i < owned; i++) { totalCost += Math.floor(config.baseCost * Math.pow(config.costMultiplier, i))} return totalCost}, getResourceHistory(timeRange = 3600000) { const cutoff = Date.now() - timeRange; return this.history.resources.filter(point => point.timestamp >= cutoff)}, getBuildingHistory(timeRange = 3600000) { const cutoff = Date.now() - timeRange; return this.history.buildings.filter(point => point.timestamp >= cutoff)}, loadHistoricalData() { try { const saved = localStorage.getItem('idlecity_statistics_history'); if (saved) { const data = JSON.parse(saved); this.history = { ...this.history, ...data }; this.milestones = { ...this.milestones, ...(data.milestones || {}) }} } catch (error) { console.warn('Failed to load statistics history:', error)} }, saveHistoricalData() { try { const dataToSave = { ...this.history, milestones: this.milestones }; localStorage.setItem('idlecity_statistics_history', JSON.stringify(dataToSave))} catch (error) { console.warn('Failed to save statistics history:', error)} }, reset() { this.history = { resources: [], buildings: [], achievements: [], sessions: [] }; this.milestones = { firstClick: false, first100Coins: false, first10Buildings: false, first100Population: false, firstHour: false, firstAchievement: false }; this.startNewSession(); try { localStorage.removeItem('idlecity_statistics_history')} catch (error) { console.warn('Failed to clear statistics history:', error)} } }; setInterval(() => { if (typeof Statistics !== 'undefined') { Statistics.saveHistoricalData()} }, 60000); if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { setTimeout(() => { if (typeof GameState !== 'undefined') { Statistics.init()} else { console.warn('⚠️ GameState not ready, delaying statistics init'); setTimeout(() => Statistics.init(), 1000)} }, 700)})} else { setTimeout(() => { if (typeof GameState !== 'undefined') { Statistics.init()} else { console.warn('⚠️ GameState not ready, delaying statistics init'); setTimeout(() => Statistics.init(), 1000)} }, 700)}