const PWA = { serviceWorker: null, pushSubscription: null, installPrompt: null, isInstalled: false, isOnline: navigator.onLine, init() { console.log('📱 Initializing PWA features...'); try { this.registerServiceWorker(); this.setupInstallPrompt(); this.setupPushNotifications(); this.setupOfflineHandling(); this.setupPeriodicSync(); this.createInstallButton(); this.setupNotificationButton(); this.setupIdleNotifications(); console.log('✅ PWA features initialized')} catch (error) { console.error('❌ PWA initialization failed:', error)} }, async registerServiceWorker() { if (!('serviceWorker' in navigator)) { console.warn('⚠️ Service Worker not supported'); return} try { const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/' }); this.serviceWorker = registration; console.log('✅ Service Worker registered:', registration.scope); registration.addEventListener('updatefound', () => { const newWorker = registration.installing; newWorker.addEventListener('statechange', () => { if (newWorker.state === 'installed' && navigator.serviceWorker.controller) { this.showUpdateNotification()} })}); navigator.serviceWorker.addEventListener('message', (event) => { this.handleServiceWorkerMessage(event.data)})} catch (error) { console.error('❌ Service Worker registration failed:', error)} }, setupInstallPrompt() { window.addEventListener('beforeinstallprompt', (event) => { console.log('📲 Install prompt available'); event.preventDefault(); this.installPrompt = event; this.showInstallButton()}); window.addEventListener('appinstalled', () => { console.log('✅ App installed'); this.isInstalled = true; this.hideInstallButton(); if (typeof UI !== 'undefined') { UI.showNotification('IdleCity installed successfully! 🎉', 'success', 4000)} })}, async setupPushNotifications() { if (!('Notification' in window) || !('serviceWorker' in navigator)) { console.warn('⚠️ Push notifications not supported'); return} const permission = Notification.permission; console.log('🔔 Notification permission:', permission); if (permission === 'granted') { await this.subscribeToPush()} }, async requestNotificationPermission() { if (!('Notification' in window)) { console.warn('⚠️ Notifications not supported'); return false} const permission = await Notification.requestPermission(); console.log('🔔 Notification permission result:', permission); if (permission === 'granted') { await this.subscribeToPush(); if (typeof UI !== 'undefined') { UI.showNotification('Notifications enabled! You\'ll get updates about your city.', 'success', 4000)} return true} return false}, async subscribeToPush() { if (!this.serviceWorker) { console.warn('⚠️ Service Worker not available for push subscription'); return} try { const vapidPublicKey = 'BEl62iUYgUivxIkv69yViEuiBIa40HI80NM9f8HnKJuOmqmkNpQHC7WgXr1gYWChNw_bHVLdyuUFgpEjsm6YBWo'; const subscription = await this.serviceWorker.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: this.urlBase64ToUint8Array(vapidPublicKey) }); this.pushSubscription = subscription; console.log('✅ Push subscription created:', subscription)} catch (error) { console.error('❌ Push subscription failed:', error)} }, setupOfflineHandling() { window.addEventListener('online', () => { console.log('🌐 Back online'); this.isOnline = true; this.handleOnlineStateChange()}); window.addEventListener('offline', () => { console.log('📴 Gone offline'); this.isOnline = false; this.handleOnlineStateChange()}); this.handleOnlineStateChange()}, handleOnlineStateChange() { const indicator = this.getOrCreateOfflineIndicator(); if (this.isOnline) { indicator.style.display = 'none'; this.syncPendingData(); if (typeof UI !== 'undefined') { UI.showNotification('Connection restored! 🌐', 'success', 2000)} } else { indicator.style.display = 'block'; if (typeof UI !== 'undefined') { UI.showNotification('You\'re offline. Game will continue to work! 📴', 'info', 3000)} } }, async setupPeriodicSync() { if (!('serviceWorker' in navigator) || !('periodicSync' in window.ServiceWorkerRegistration.prototype)) { console.warn('⚠️ Periodic Background Sync not supported'); return} try { const registration = await navigator.serviceWorker.ready; await registration.periodicSync.register('idle-check', { minInterval: 30 * 60 * 1000 }); console.log('✅ Periodic sync registered')} catch (error) { console.error('❌ Periodic sync registration failed:', error)} }, createInstallButton() { const installBtn = document.createElement('button'); installBtn.id = 'pwa-install-btn'; installBtn.className = 'fixed bottom-4 right-4 bg-game-primary hover:bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg transition-all duration-300 transform translate-y-20 opacity-0 z-50'; installBtn.innerHTML = '📱 Install App'; installBtn.style.display = 'none'; installBtn.addEventListener('click', () => { this.showInstallPrompt()}); document.body.appendChild(installBtn)}, showInstallButton() { const installBtn = document.getElementById('pwa-install-btn'); if (installBtn && this.installPrompt && !this.isInstalled) { installBtn.style.display = 'block'; setTimeout(() => { installBtn.classList.remove('translate-y-20', 'opacity-0')}, 100)} }, hideInstallButton() { const installBtn = document.getElementById('pwa-install-btn'); if (installBtn) { installBtn.classList.add('translate-y-20', 'opacity-0'); setTimeout(() => { installBtn.style.display = 'none'}, 300)} }, async showInstallPrompt() { if (!this.installPrompt) { console.warn('⚠️ Install prompt not available'); return} try { this.installPrompt.prompt(); const result = await this.installPrompt.userChoice; console.log('📲 Install prompt result:', result.outcome); if (result.outcome === 'accepted') { console.log('✅ User accepted install prompt')} else { console.log('❌ User dismissed install prompt')} this.installPrompt = null; this.hideInstallButton()} catch (error) { console.error('❌ Install prompt failed:', error)} }, showUpdateNotification() { if (typeof UI !== 'undefined') { const notification = UI.showNotification( 'A new version is available! Click to update.', 'info', 0, [ { text: 'Update Now', action: () => { this.applyUpdate()} }, { text: 'Later', action: () => { } } ] )} }, async applyUpdate() { if (!this.serviceWorker) return; try { if (this.serviceWorker.waiting) { this.serviceWorker.waiting.postMessage({ type: 'SKIP_WAITING' })} window.location.reload()} catch (error) { console.error('❌ Update failed:', error)} }, handleServiceWorkerMessage(data) { console.log('💬 Message from Service Worker:', data); switch (data.type) { case 'SYNC_GAME_DATA': this.syncGameData(); break; default: console.log('Unknown message type:', data.type)} }, async syncGameData() { console.log('🔄 Syncing game data...'); try { if (typeof Storage !== 'undefined') { Storage.saveGame()} if (this.serviceWorker && this.serviceWorker.active) { this.serviceWorker.active.postMessage({ type: 'CACHE_GAME_STATE', data: { gameState: GameState } })} console.log('✅ Game data synced')} catch (error) { console.error('❌ Game data sync failed:', error)} }, async syncPendingData() { if (!this.isOnline) return; console.log('🔄 Syncing pending data...'); try { if (this.serviceWorker) { const registration = await navigator.serviceWorker.ready; await registration.sync.register('save-game-data')} } catch (error) { console.error('❌ Background sync registration failed:', error)} }, async sendIdleNotification(message, data = {}) { if (Notification.permission !== 'granted') { return} try { if (this.serviceWorker) { const registration = await navigator.serviceWorker.ready; await registration.showNotification('IdleCity', { body: message, icon: '/manifest.json', badge: '/manifest.json', tag: 'idle-notification', requireInteraction: false, actions: [ { action: 'open-game', title: 'Open Game' } ], data: { url: '/', ...data } })} } catch (error) { console.error('❌ Idle notification failed:', error)} }, getOrCreateOfflineIndicator() { let indicator = document.getElementById('offline-indicator'); if (!indicator) { indicator = document.createElement('div'); indicator.id = 'offline-indicator'; indicator.className = 'fixed top-0 left-0 right-0 bg-yellow-500 text-white text-center py-2 px-4 z-50 transform -translate-y-full transition-transform duration-300'; indicator.innerHTML = '📴 You\'re offline - Game continues to work!'; indicator.style.display = 'none'; document.body.appendChild(indicator); setTimeout(() => { indicator.classList.remove('-translate-y-full')}, 100)} return indicator}, urlBase64ToUint8Array(base64String) { const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i < rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i)} return outputArray}, isPWA() { return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true}, setupNotificationButton() { const notificationBtn = document.getElementById('enableNotificationsBtn'); if (!notificationBtn) return; if ('Notification' in window && Notification.permission === 'default') { notificationBtn.style.display = 'flex'} notificationBtn.addEventListener('click', async () => { const granted = await this.requestNotificationPermission(); if (granted) { notificationBtn.style.display = 'none'; setTimeout(() => { this.sendIdleNotification('Notifications enabled! You\'ll get updates about your city progress.')}, 1000)} })}, setupIdleNotifications() { setInterval(() => { this.checkForIdleNotifications()}, 5 * 60 * 1000); document.addEventListener('visibilitychange', () => { if (document.hidden) { this.startIdleTracking()} else { this.stopIdleTracking(); this.checkIdleProgress()} })}, startIdleTracking() { this.idleStartTime = Date.now(); this.idleNotificationTimer = setTimeout(() => { this.sendLongIdleNotification()}, 30 * 60 * 1000)}, stopIdleTracking() { if (this.idleNotificationTimer) { clearTimeout(this.idleNotificationTimer); this.idleNotificationTimer = null} this.idleStartTime = null}, checkForIdleNotifications() { if (typeof GameState === 'undefined' || !GameState) return; const coinsPerSecond = GameState.resources.coinsPerSecond || 0; const populationPerSecond = GameState.resources.populationPerSecond || 0; if (coinsPerSecond > 10 || populationPerSecond > 1) { const lastActivity = this.getLastActivityTime(); const timeSinceActivity = Date.now() - lastActivity; if (timeSinceActivity > 10 * 60 * 1000) { const message = `Your city is thriving! Earning ${coinsPerSecond.toFixed(1)} coins/sec and growing by ${populationPerSecond.toFixed(1)} people/sec.`; this.sendIdleNotification(message)} } }, checkIdleProgress() { if (!this.idleStartTime || typeof GameState === 'undefined') return; const idleTime = Date.now() - this.idleStartTime; const idleMinutes = Math.floor(idleTime / (60 * 1000)); if (idleMinutes >= 5) { const coinsPerSecond = GameState.resources.coinsPerSecond || 0; const coinsEarned = Math.floor(coinsPerSecond * (idleTime / 1000)); if (coinsEarned > 0) { if (typeof UI !== 'undefined') { UI.showNotification( `Welcome back! Your city earned approximately ${coinsEarned} coins while you were away (${idleMinutes} minutes).`, 'success', 5000 )} } } }, sendLongIdleNotification() { if (typeof GameState === 'undefined') return; const coinsPerSecond = GameState.resources.coinsPerSecond || 0; const estimatedCoins = Math.floor(coinsPerSecond * 30 * 60); let message = 'Your city has been growing while you were away!'; if (estimatedCoins > 0) { message = `Your city earned approximately ${estimatedCoins} coins in the last 30 minutes!`} this.sendIdleNotification(message, { action: 'return', estimatedCoins: estimatedCoins })}, getLastActivityTime() { return this.lastActivityTime || Date.now()}, updateLastActiveTime() { this.lastActivityTime = Date.now(); if (this.serviceWorker && this.serviceWorker.active) { this.serviceWorker.active.postMessage({ type: 'UPDATE_LAST_ACTIVE', data: { timestamp: Date.now() } })} } }; if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { PWA.init()})} else { PWA.init()} ['click', 'keydown', 'scroll', 'touchstart'].forEach(eventType => { document.addEventListener(eventType, () => { PWA.updateLastActiveTime()}, { passive: true })}); if (typeof window !== 'undefined') { window.PWA = PWA}