const Performance = { metrics: { frameRate: 60, averageFrameTime: 16.67, frameHistory: [], memoryUsage: 0, domUpdateCount: 0, errorCount: 0, lastFrameTime: 0, performanceScore: 100 }, settings: { targetFrameRate: 60, minFrameRate: 30, maxFrameRate: 120, adaptivePerformance: true, memoryCleanupInterval: 300000, performanceReportInterval: 60000, maxFrameHistory: 60, errorThreshold: 10 }, state: { isRunning: false, isDegraded: false, lastCleanup: Date.now(), lastReport: Date.now(), animationFrameId: null, performanceObserver: null }, domUpdates: { pending: new Map(), batchTimeout: null, batchSize: 0 }, memory: { trackedObjects: new WeakSet(), eventListeners: new Map(), intervals: new Set(), timeouts: new Set(), caches: new Map() }, errors: { handlers: new Map(), recoveryStrategies: new Map(), errorLog: [] }, init() { console.log('⚡ Initializing performance management system...'); try { this.checkBrowserCompatibility(); this.initPerformanceMonitoring(); this.initMemoryManagement(); this.initErrorHandling(); this.start(); console.log('✅ Performance management system initialized'); return true} catch (error) { console.error('❌ Failed to initialize performance system:', error); this.handleError('init', error); return false} }, checkBrowserCompatibility() { const features = { requestAnimationFrame: typeof requestAnimationFrame !== 'undefined', performance: typeof performance !== 'undefined' && performance.now, weakSet: typeof WeakSet !== 'undefined', map: typeof Map !== 'undefined', localStorage: this.checkLocalStorage(), webWorkers: typeof Worker !== 'undefined', performanceObserver: typeof PerformanceObserver !== 'undefined' }; console.log('🔍 Browser compatibility check:', features); if (!features.requestAnimationFrame) { window.requestAnimationFrame = (callback) => setTimeout(callback, 16); window.cancelAnimationFrame = clearTimeout} if (!features.performance) { window.performance = { now: () => Date.now() }} return features}, checkLocalStorage() { try { const test = '__test__'; localStorage.setItem(test, test); localStorage.removeItem(test); return true} catch (e) { return false} }, initPerformanceMonitoring() { if (typeof PerformanceObserver !== 'undefined') { try { this.state.performanceObserver = new PerformanceObserver((list) => { const entries = list.getEntries(); entries.forEach(entry => { if (entry.entryType === 'measure') { this.recordPerformanceEntry(entry)} })}); this.state.performanceObserver.observe({ entryTypes: ['measure'] })} catch (error) { console.warn('⚠️ PerformanceObserver not fully supported:', error)} } this.metrics.lastFrameTime = performance.now()}, initMemoryManagement() { const cleanupInterval = setInterval(() => { this.performMemoryCleanup()}, this.settings.memoryCleanupInterval); this.memory.intervals.add(cleanupInterval); if (performance.memory) { setInterval(() => { this.metrics.memoryUsage = performance.memory.usedJSHeapSize}, 5000)} }, initErrorHandling() { const originalErrorHandler = window.onerror; window.onerror = (message, source, lineno, colno, error) => { this.handleError('global', error || new Error(message), { source, lineno, colno }); if (originalErrorHandler) { return originalErrorHandler(message, source, lineno, colno, error)} return false}; window.addEventListener('unhandledrejection', (event) => { this.handleError('promise', event.reason)}); this.registerErrorRecovery('gameLoop', () => { console.log('🔄 Attempting to restart game loop...'); if (typeof GameLoop !== 'undefined') { GameLoop.stop(); setTimeout(() => GameLoop.start(), 1000)} }); this.registerErrorRecovery('ui', () => { console.log('🔄 Attempting to refresh UI...'); if (typeof UI !== 'undefined') { try { UI.updateAll()} catch (error) { console.warn('UI refresh failed:', error)} } })}, start() { if (this.state.isRunning) return; this.state.isRunning = true; this.startPerformanceLoop(); console.log('🚀 Performance monitoring started')}, stop() { if (!this.state.isRunning) return; this.state.isRunning = false; if (this.state.animationFrameId) { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null} console.log('⏹️ Performance monitoring stopped')}, startPerformanceLoop() { const loop = (currentTime) => { if (!this.state.isRunning) return; const frameTime = currentTime - this.metrics.lastFrameTime; this.metrics.lastFrameTime = currentTime; this.updateFrameMetrics(frameTime); if (this.settings.adaptivePerformance) { this.adjustPerformance()} this.processBatchedDOMUpdates(); this.performPeriodicMaintenance(currentTime); this.state.animationFrameId = requestAnimationFrame(loop)}; this.state.animationFrameId = requestAnimationFrame(loop)}, updateFrameMetrics(frameTime) { this.metrics.frameHistory.push(frameTime); if (this.metrics.frameHistory.length > this.settings.maxFrameHistory) { this.metrics.frameHistory.shift()} const sum = this.metrics.frameHistory.reduce((a, b) => a + b, 0); this.metrics.averageFrameTime = sum / this.metrics.frameHistory.length; this.metrics.frameRate = 1000 / this.metrics.averageFrameTime; this.updatePerformanceScore()}, updatePerformanceScore() { let score = 100; if (this.metrics.frameRate < this.settings.minFrameRate) { score -= (this.settings.minFrameRate - this.metrics.frameRate) * 2} if (this.metrics.memoryUsage > 100 * 1024 * 1024) { score -= 20} score -= this.metrics.errorCount * 5; this.metrics.performanceScore = Math.max(0, Math.min(100, score)); if (this.metrics.performanceScore < 30 && !this.state.isDegraded) { this.enterDegradedMode()} else if (this.metrics.performanceScore > 70 && this.state.isDegraded) { this.exitDegradedMode()} }, adjustPerformance() { if (typeof GameLoop !== 'undefined' && GameLoop.tickRate) { if (this.metrics.frameRate < this.settings.minFrameRate) { GameLoop.tickRate = Math.min(200, GameLoop.tickRate + 10)} else if (this.metrics.frameRate > this.settings.targetFrameRate) { GameLoop.tickRate = Math.max(50, GameLoop.tickRate - 5)} } }, enterDegradedMode() { console.warn('⚠️ Entering degraded performance mode'); this.state.isDegraded = true; if (typeof GameLoop !== 'undefined') { GameLoop.tickRate = Math.max(GameLoop.tickRate, 200)} this.disableNonEssentialFeatures(); if (typeof UI !== 'undefined') { UI.showNotification( 'Performance mode activated - some features reduced for better performance', 'warning', 5000 )} }, exitDegradedMode() { console.log('✅ Exiting degraded performance mode'); this.state.isDegraded = false; this.enableNonEssentialFeatures(); if (typeof UI !== 'undefined') { UI.showNotification('Performance restored - all features enabled', 'success', 3000)} }, disableNonEssentialFeatures() { document.documentElement.style.setProperty('--animation-duration', '0.1s'); document.body.classList.add('performance-mode')}, enableNonEssentialFeatures() { document.documentElement.style.removeProperty('--animation-duration'); document.body.classList.remove('performance-mode')}, batchDOMUpdate(element, property, value) { const key = `${element.id || element.tagName}-${property}`; this.domUpdates.pending.set(key, { element, property, value, timestamp: performance.now() }); this.domUpdates.batchSize++; if (!this.domUpdates.batchTimeout) { this.domUpdates.batchTimeout = setTimeout(() => { this.processBatchedDOMUpdates()}, 16)} }, processBatchedDOMUpdates() { if (this.domUpdates.pending.size === 0) return; const startTime = performance.now(); for (const [key, update] of this.domUpdates.pending) { try { if (update.property === 'textContent') { update.element.textContent = update.value} else if (update.property === 'innerHTML') { update.element.innerHTML = update.value} else if (update.property === 'style') { Object.assign(update.element.style, update.value)} else if (update.property === 'className') { update.element.className = update.value} else { update.element[update.property] = update.value} } catch (error) { this.handleError('domUpdate', error, { key, update })} } this.domUpdates.pending.clear(); this.domUpdates.batchTimeout = null; this.domUpdates.batchSize = 0; const endTime = performance.now(); this.metrics.domUpdateCount++; if (endTime - startTime > 5) { console.warn(`⚠️ DOM batch update took ${(endTime - startTime).toFixed(2)}ms`)} }, performMemoryCleanup() { console.log('🧹 Performing memory cleanup...'); const startTime = performance.now(); try { this.showCleanupIndicator(); this.cleanupCaches(); this.cleanupEventListeners(); if (window.gc) { window.gc()} this.state.lastCleanup = Date.now(); const endTime = performance.now(); console.log(`✅ Memory cleanup completed in ${(endTime - startTime).toFixed(2)}ms`)} catch (error) { this.handleError('memoryCleanup', error)} }, cleanupCaches() { for (const [key, cache] of this.memory.caches) { if (cache.expiry && Date.now() > cache.expiry) { this.memory.caches.delete(key)} } }, cleanupEventListeners() { for (const [element, listeners] of this.memory.eventListeners) { if (!document.contains(element)) { listeners.forEach(({ event, handler }) => { element.removeEventListener(event, handler)}); this.memory.eventListeners.delete(element)} } }, trackEventListener(element, event, handler) { if (!this.memory.eventListeners.has(element)) { this.memory.eventListeners.set(element, [])} this.memory.eventListeners.get(element).push({ event, handler })}, handleError(context, error, details = {}) { this.metrics.errorCount++; const errorInfo = { context, error: error.message || error, stack: error.stack, details, timestamp: Date.now(), url: window.location.href, userAgent: navigator.userAgent }; console.error(`❌ Error in ${context}:`, error, details); this.errors.errorLog.push(errorInfo); if (this.errors.errorLog.length > 100) { this.errors.errorLog.shift()} this.attemptErrorRecovery(context, error); if (this.metrics.errorCount > this.settings.errorThreshold) { this.enterSafeMode()} }, registerErrorRecovery(context, recoveryFunction) { this.errors.recoveryStrategies.set(context, recoveryFunction)}, attemptErrorRecovery(context, error) { const recovery = this.errors.recoveryStrategies.get(context); if (recovery) { try { recovery(error); console.log(`🔄 Recovery attempted for ${context}`)} catch (recoveryError) { console.error(`❌ Recovery failed for ${context}:`, recoveryError)} } }, enterSafeMode() { console.warn('🚨 Entering safe mode due to excessive errors'); this.stop(); if (typeof UI !== 'undefined') { UI.showNotification( 'Safe mode activated due to errors. Some features may be limited.', 'error', 10000 )} }, performPeriodicMaintenance(currentTime) { if (currentTime - this.state.lastReport > this.settings.performanceReportInterval) { this.generatePerformanceReport(); this.state.lastReport = currentTime} if (currentTime - this.state.lastCleanup > this.settings.memoryCleanupInterval) { this.performMemoryCleanup()} }, generatePerformanceReport() { const report = { timestamp: Date.now(), frameRate: Math.round(this.metrics.frameRate), averageFrameTime: Math.round(this.metrics.averageFrameTime * 100) / 100, memoryUsage: this.metrics.memoryUsage, performanceScore: Math.round(this.metrics.performanceScore), domUpdateCount: this.metrics.domUpdateCount, errorCount: this.metrics.errorCount, isDegraded: this.state.isDegraded }; console.log('📊 Performance Report:', report); this.updatePerformanceIndicator(report); if (!window.performanceReports) { window.performanceReports = []} window.performanceReports.push(report); if (window.performanceReports.length > 60) { window.performanceReports.shift()} }, updatePerformanceIndicator(report) { const indicator = document.getElementById('performanceIndicator'); const fpsCounter = document.getElementById('fpsCounter'); const perfScore = document.getElementById('perfScore'); if (indicator && fpsCounter && perfScore) { if (report.performanceScore < 80 || report.frameRate < 45) { indicator.classList.add('show'); indicator.classList.remove('good', 'degraded'); if (report.performanceScore < 50) { indicator.classList.add('degraded')} else if (report.performanceScore > 80) { indicator.classList.add('good')} fpsCounter.textContent = report.frameRate; perfScore.textContent = report.performanceScore} else { indicator.classList.remove('show')} } }, showCleanupIndicator() { const indicator = document.getElementById('cleanupIndicator'); if (indicator) { indicator.style.display = 'block'; setTimeout(() => { indicator.style.display = 'none'}, 2000)} }, getMetrics() { return { ...this.metrics }}, getReport() { return { metrics: this.getMetrics(), state: { ...this.state }, settings: { ...this.settings }, recentErrors: this.errors.errorLog.slice(-10) }}, cleanup() { console.log('🧹 Cleaning up performance system...'); this.stop(); this.memory.intervals.forEach(id => clearInterval(id)); this.memory.timeouts.forEach(id => clearTimeout(id)); if (this.state.performanceObserver) { this.state.performanceObserver.disconnect()} console.log('✅ Performance system cleanup completed')} }; if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { setTimeout(() => Performance.init(), 100)})} else { setTimeout(() => Performance.init(), 100)} window.addEventListener('beforeunload', () => { Performance.cleanup()}); window.Performance = Performance;